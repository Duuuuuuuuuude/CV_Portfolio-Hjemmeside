# Docker
# Build a Docker image
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

trigger:
- main

resources:
- repo: self

variables:
- group: Container-Registry-do
- name: containerRegistryServiceConnection
  value: 'azure_pipeline/DigitalOcean-ContainerRegistry/koldste.dev'
- name: registryName
  value: koldste-dev-digitalocean-container-registry

  # release pipeline variables
  # - group: Container-Registry-do
- name: imagePullSecret
  value: azure-secret-registry-$(registryName)
- name: k8sNamespace
  value: backend
- name: containerRegistryURL
  value: 'registry.digitalocean.com'
- name: containerRegistryAPIBaseURL
  value: 'https://api.digitalocean.com/v2/registry/$(registryName)'

stages:
- stage: Build
  displayName: Build image
  jobs:
  - job: Build
    displayName: Build, push and publish artifact
    pool:
      vmImage: ubuntu-latest
    steps:

    - task: Bash@3
      displayName: 'Waits for the garbage collection to be done, if necessary'
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash

          retries=20
          seconds_between_retries=20

          # Gets active garbage collection
          for ((i=1; i<=retries; i++))
          do
            echo "Getting active garbage collection"
            response=$(curl --silent \
                            --write-out "HTTPSTATUS:%{http_code}" \
                            -X GET \
                            -H "Content-Type: application/json" \
                            -H "Authorization: Bearer "$(bearerTokenContainerRegistry)"" \
                            ""$(containerRegistryAPIBaseURL)"/garbage-collection")
                                
            # Separate the JSON response from the HTTP status
            http_status_code=$(echo $response | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
            json_response=$(echo $response | sed -e 's/HTTPSTATUS\:.*//g')

            # Checks the HTTP status error codes
            if [ $http_status_code -eq 404 ]; then
              echo "HTTP status code: $http_status_code"
              echo "No active garbage collection found. Continuing to push image."
              echo "Response body: $json_response"
              echo
              exit 0

            elif [ $http_status_code -eq 200 ]; then
              echo "HTTP status code: $http_status_code"
              echo "Response body: $json_response"
              echo "Active garbage collection found. Trying again in $seconds_between_retries seconds."

              # 20 second sleep with a loading bar.
              end=$20
              for number in $(seq 1 $_end)
              do
                sleep 1s
                # Process data
                let _progress=($number*100/$_end*100)/100
                let _done=($_progress*4)/10
                let _left=40-$_done
                # Build progressbar string lengths
                _fill=$(printf "%${_done}s")
                _empty=$(printf "%${_left}s")
                printf "\rProgress : [${_fill// /#}${_empty// /-}] ${_progress}%%"
              done

            else
              echo "HTTP status code: $http_status_code"
              echo "Response body: $json_response"
              echo
            fi

          done
        failOnStderr: true

    - task: Docker@2
      displayName: 'Build and push an image to container registry'
      inputs:
        containerRegistry: '$(containerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'buildAndPush'
        Dockerfile: '**/Dockerfile'
        buildContext: '.'
        tags: '$(tag)'
        
    - task: PublishPipelineArtifact@1
      inputs:
        artifactName: 'Manifests'
        path: 'Koldste.dev.Web/Manifests'



# Release pipeline
- stage: Deploy
  displayName: Deploy stage
  dependsOn: Build
  jobs:
  - deployment: Deploy
    displayName: Deploy job
    pool:
      vmImage: ubuntu-latest
    environment: koldstedev-do-kubernetes
    strategy:
      runOnce:
        deploy:
          steps:

          - task: DownloadPipelineArtifact@2
            inputs:
              artifactName: 'Manifests'
              downloadPath: '$(System.ArtifactsDirectory)/Manifests'

          - task: KubernetesManifest@1
            displayName: Create imagePullSecret
            inputs:
              action: 'createSecret'
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceConnection: 'koldstedev-do-kubernetes-backend-1711399786755'
              namespace: '$(k8sNamespace)'
              secretType: 'dockerRegistry'
              secretName: '$(imagePullSecret)'
              dockerRegistryEndpoint: 'azure_pipeline/DigitalOcean-ContainerRegistry/koldste.dev'

          - script: |
              sed -i "s|{{DOCKER_IMAGE_NAME}}|$(containerRegistryURL)/$(imageRepository)|g" $(System.ArtifactsDirectory)/Manifests/website-koldstedev/Deployment_koldstedev.yaml
              sed -i "s|{{DOCKER_IMAGE_TAG}}|$(tag)|" $(System.ArtifactsDirectory)/Manifests/website-koldstedev/Deployment_koldstedev.yaml
            displayName: 'Replace Docker image name and tag in deployment manifest file'

          - task: KubernetesManifest@1
            displayName: Deploy to Kubernetes cluster
            inputs:
              action: 'deploy'
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceConnection: 'koldstedev-do-kubernetes-backend-1711399786755'
              namespace: '$(k8sNamespace)'
              manifests: |
                $(System.ArtifactsDirectory)/Manifests/website-koldstedev/Deployment_koldstedev.yaml
                $(System.ArtifactsDirectory)/Manifests/website-koldstedev/Service_koldstedev.yaml
              imagePullSecrets: '$(imagePullSecret)'
              rolloutStatusTimeout: '180'

########## ROLLBACK HERE



          - task: Bash@3
            displayName: 'Clean up the container registry'
            inputs:
              targetType: 'inline'
              script: |
                #!/bin/bash

                min_to_keep=10
                delete_days_old=3
                verbose=yes

                # Gets all tags in repository
                response=$(curl --silent \
                                --write-out "HTTPSTATUS:%{http_code}" \
                                -X GET \
                                -H "Content-Type: application/json" \
                                -H "Authorization: Bearer "$(bearerTokenContainerRegistry)"" \
                                ""$(containerRegistryAPIBaseURL)"/repositories/"$(repositoryNameURLEncoded)"/tags?per_page=200")

                # Separates the JSON response from the HTTP status
                http_status=$(echo $response | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
                json_response=$(echo $response | sed -e 's/HTTPSTATUS\:.*//g')

                # Checks the HTTP status code and exits if the HTTP request failed. Also prints out the json body, if it failed and message if there was nothing to delete
                if [ $http_status -eq 404 ]; then
                    echo "Error: HTTP response $http_status"
                fi

                if [ $http_status -eq 404 ] && [[ "$verbose" == "yes" ]]; then
                    echo "Nothing to delete"
                    exit 0
                elif [ $http_status -ne 200 ]; then
                    echo "Error: HTTP response $http_status"
                    echo "Response body: $json_response"
                    exit 1
                fi

                date_boundary=$(date -d"-$delete_days_old days" +%s)
                # deletable_tags=$(echo $json_response | jq ".tags[] | .[10:] | .[] | select ( .updated_at | fromdateiso8601 < $date_boundary) | .tag | .[10:] " -r | tr '\n' ' ')
                # deletable_tags=$(echo $json_response | jq ".tags[] | select ( .updated_at | fromdateiso8601 < $date_boundary) | .tag " -r | tail -n +11 | tr '\n' ' ')
                deletable_tags=$(echo $json_response | jq -r ".tags[] | select ( .updated_at | fromdateiso8601 < $date_boundary) | .tag | .[10:] " | tr '\n' ' ')


                # Check the exit status of jq for errors
                if [ $? -ne 0 ]; then
                    echo "Error: jq command failed"
                    exit 1
                fi
      
                [[ "$verbose" == "yes" ]] && {
                  echo "DELETING images in the container registry, that are more than $delete_days_old days"
                  echo "While KEEPING at least $min_to_keep of the newest images in the container registry"
                  echo ""
                  echo "Tags from the images being deleted:"
                  echo "Deleteable tags: $deletable_tags"
                }

                # Tags being deleted on the images in container registry.
                for tag in $deletable_tags; do
                  response=$(curl --silent \
                                  --write-out "HTTPSTATUS:%{http_code}" \
                                  -X DELETE \
                                  -H "Content-Type: application/json" \
                                  -H "Authorization: Bearer "$(bearerTokenContainerRegistry)"" \
                                  ""$(containerRegistryAPIBaseURL)"/repositories/"$(repositoryNameURLEncoded)"/tags/$tag")

                  # Separate the JSON response from the HTTP status
                  http_status=$(echo $response | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
                  json_response=$(echo $response | sed -e 's/HTTPSTATUS\:.*//g')

                  # Checks the HTTP status error codes
                  if [$http_status -eq 404] && [[ "$verbose" == "yes" ]]; then
                    echo "Response body: $json_response"
                  fi

                  if [ $http_status -ne 200 ] && [ $http_status -ne 404]; then
                    echo "Error: HTTP response $http_status"
                    echo "Response body: $json_response"
                    exit 1
                  fi
                done

                # This will run a garbage collection and delete images no longer used and untagged images.
                response=$(curl --silent \
                                --write-out "HTTPSTATUS:%{http_code}" \
                                -X POST \
                                -H "Content-Type: application/json" \
                                -H "Authorization: Bearer "$(bearerTokenContainerRegistry)"" \
                                ""$(containerRegistryAPIBaseURL)"/garbage-collection")
                                
                # Separate the JSON response from the HTTP status
                http_status=$(echo $response | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
                json_response=$(echo $response | sed -e 's/HTTPSTATUS\:.*//g')

                # Checks the HTTP status error codes
                if [ $http_status -ne 201 ]; then
                  echo "Error: HTTP response $http_status"
                  echo "Response body: $json_response"
                  exit 1
                fi
              failOnStderr: true




          